<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
</head>
<body>
	<script>
	/*
		理解对象：对象的属性  ， 数据属性和访问器属性  
					数据属性来保存数据值 
					访问器属性：不包含数据值，包含一对getter和setter函数（不过不是必须的）；	
				属性的特性：数据属性有4个特性：
												[[Configurable]]：表示能否使用delelte删除属性，能否修改属性特性。默认为true
												[[Enumerabler]]:表示能否通过for-in枚举属性。默认为true
												[[Writable]] : 表示能否修改属性的值。 默认为true
												[[Value]]:包含这个属性的值。
							访问器属性：：  [[Configurable]]：表示能否使用delelte删除属性，能否修改属性特性。默认为true
											[[Enumerabler]]:表示能否通过for-in枚举属性。默认为true
											[[Get]]:在读取属性时调用的函数，默认值为undefined.
											[[Set]]:在设置属性时调用的函数，默认值为undefined.
				使用Object.defineProperty()设置特性的值。
				使用Object.defineProperties()方法来同事定义多个属性。
				使用Object.getOwnPropertyDescriptor()方法来读取属性特性
				使用Object.defineProperty()来定义访问器属性  （只传2个参宿）
 */	



 /*
 	创建对象：工厂模式 ： 使用简单的函数创建对象，然后为最想添加方法和属性，之后返回对象。
 			  构造函数模式：可以创建自定义引用类型，可以像创建内置对象实例一样使用new操作符。
 			  				缺点：每个成员都无法得到复用，包括函数
			  原型模式：使用构造函数的prototype属性来定义属性和方法，但是会引起引用类型值得共享问题。
			  组合模式： 将构造函数模式和原型模式组合起来，构造函数定义实例属性和方法，原型定义共享属性和方法
*/

/*
	继承：主要通过原型链来实现，将超类的实例赋值给子类的原型来实现继承。 此继承方式的问题是所有实例会共享所有继承的属性和方法
			使用借用构造函数来解决，即在子类型的构造函数中使用call或者apply来“借用”超类的构造函数。
			使用最多的是组合继承：原型链继承共享的属性和方法。借用构造函数来继承实例属性


		原型式继承：可以在不必预先定义构造函数的情况下实现继承，其本执行对给定对象的浅复制。还可以对其进行改造。
		寄生式继承：与原型式继承非常相似，基于某个对象或某些信息创建一个对象，然后增强对象。最后返回对象。
		寄生组合式继承：可以解决组合继承模式由于多次调用超类型构造函数而导致的低效率问题，集寄生式继承和组合继承的优点，是实现基于类型继承的最好方式。
 */
	
	</script>
</body>
</html>