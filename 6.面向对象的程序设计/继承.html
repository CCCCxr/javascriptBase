<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
</head>
<body>
<!-- 
	创建对象的方式：工厂模式
					构造函数模式
					原生模式
	主要实现自定义对象的方式： 使用构造函数模式和原生模式组合，构造函数定义实例的属性，原生模式定义共享的属性。
-->
<script>  
	// 继承分俩种，接口继承和实现继承；
	// ECMAScript 只支持实现继承，实现继承主要是依靠原型链来实现继承的。
	// 还可以通过借用构造函数继承，原型式继承，寄生式继承，寄生组合式继承。


	/**
	 * 原型链的构建是通过将一个类型的实例赋值给另一个构造函数的原型实现的。
	 */
	//实现原型链的基本模式：  (实现继承的时候不能使用对象字面量创建原型方法，这样会重写原型链。)
	  function SuperType() {
	  	 this.name = "zzz";
	  }
	  // SuperType.prototype.getName = function(){
	  // 	return this.name;
	  // }
	  SuperType.prototype = {
	  	getName : function(){
	  		return this.name;
	  	}
	  }

	  function SubType(){
	  	this.age = "23"
	  }
	  console.log(SubType.prototype); 
	  SubType.prototype = new SuperType();  // 继承SuperType 对象
	  console.log(SubType.prototype);  //  多了SuperType的方法和属性
	  SubType.prototype.getSubValue = function(){
	  	return this.age;
	  }
	  var c = new SubType();  
	  console.log(c.getName()); //"zzz"  实现了一个简单的继承  
	  // c是Sub的实例，拥有Sub的方法和属性，Sub的原型又是Sup的实例，所以c也有Sup的方法和属性。
	  console.log(c.constructor);
	  console.log(SuperType.prototype);
	  console.log(SubType.prototype);	

	  //确定原型和实例的关系  instanceof操作符和isPrototypeOf() 
	  console.log(c instanceof Object); // true
	  console.log(c instanceof SubType); // true
	  console.log(c instanceof SuperType); // true  

	  //只要是原型链中出现过的原型，都可以说是该原型链所派生的实例
	  console.log(Object.prototype.isPrototypeOf(c)); // true
	  console.log(SubType.prototype.isPrototypeOf(c));  // true
	  console.log(SuperType.prototype.isPrototypeOf(c));  // true

	  //谨慎的定义方法
	  // 给原型添加方法的代码一定要换在替换原型语句之后 .
	  function Aa(){
	  	this.name = "Aa";
	  }
	  Aa.prototype.getName = function(){
	  	return this.name;
	  }

	  function Bb(){
	  	this.age = "Bb";
	  }
	  Bb.prototype = new Aa();
	  Bb.prototype.getAge = function(){
	  	return this.age;
	  }
	  Bb.prototype.getName = function(){
	  	return "从写了"+this.name;
	  }
	  var Cc = new Bb();
	  console.log(Cc.getName());   
	  console.log(Aa.prototype)
	  console.log(Bb.prototype)

	  //原型链的问题 ：引用类型  不能传递参数
	  function Color(){
	  	this.color = ["red","gray","white"] 
	  }
	  function Color2(){

	  }
	  Color2.prototype = new Color();

	  var colors = new Color2();

	  colors.color.push("black"); 
	  console.log(colors.color); //["red", "gray", "white", "black"]
	  var colors2 = new Color2();
	  console.log(colors2.color); //["red", "gray", "white", "black"]
	  var colors3 = new Color2();

	  //借用构造函数  在子类型构造函数的内部调用超类型的构造函数。使用call或者applly方法
	 
	  
	  function SuperType2(){
	  	this.color = ["red","green","blue"];
	  }
	  function SubType2(){
	  	SuperType2.call(this);
	  }
	  
	  var colors3 = new SubType2();
	  var colors4 = new SubType2();
	  colors3.color.push("black");
	  console.log(colors3.color); //["red", "green", "blue", "black"]
	  console.log(colors4.color); //["red", "green", "blue"]
   		 //可以传递参数
   		 function SuperType3(name){
   		 	this.name = name;
   		 }
   		 function SubType3(){
   		 	SuperType3.call(this,"cxr");
   		 	this.age = 29;
   		 }
   		 var t = new SubType3();
   		 console.log(t.name,t.age); //cxr 29  
   		 //	 借用构造函数的问题：函数无法得到复用，而且在超类型的原型中定义的方法，子类型是不可见的。
   		 
   		 //组合继承 
   		 //思想 : 使用原型链实现对原型属性和方法的继承，通过借用构造函数来实现对实例属性的继承 
   		 
   		 function SuperType4(name){
   		 	this.name = name;
   		 	this.colors = ["red","blue","green"];
   		 }
   		 SuperType4.prototype.getName = function(){
   		 	console.log(this.name);
   		 }

   		 function SubType4(name,age){
   		 	//继承属性
   		 	SuperType4.call(this,name);

   		 	this.age = age;
   		 }
   		 //继承方法
   		 SubType4.prototype = new SuperType4();

   		 SubType4.prototype.sayAge = function(){
   		 	console.log(this.age);
   		 }

   		var j = new SubType4("cxr",45);
   		j.colors.push("black");
   		console.log(j.colors);
   		j.getName();
   		j.sayAge();
   		var c = new SubType4("cxr2",20);
   		console.log(c.__proto__);
   		c.colors.push("gray");
   		console.log(c.colors);
   		c.getName();
   		c.sayAge();
</script> 
</body>
</html>