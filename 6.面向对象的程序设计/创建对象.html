<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>
    // 虽然使用Object构造函数或者对象字面量都可以创建单个对象，但这些方式有个明显的缺点：使用同一个接口创建很多对象，会产生大量的重复代码
    // 为了解决这个问题。人们开始使用工厂模式的一种变体。

    /**
     * 工厂模式  这种模式抽象了创建对象的具体过程。使用函数来封装以特定接口创建对象的细节
     *  使用封装过的函数虽然可以解决创建相似对象的问题，但是却没有识别对象识别的问题
     */
    function creatPerson(name,age,job){
        var o = new Object();
        o.name = name;
        o.age = age;
        o.job = job;
        o.sayName = sayName;
        return o;
    }

    var cxr = creatPerson("cxr",26,"web");

    /**
     * 构造函数模式   ECMAScript中的构造函数可以用来创建特定类型的对象。 例如Object,Array这样的原生构造函数
     *              在运行的时候会自动出现在执行环境中。也可以创建自定义的构造函数，从而定义自定义创建的对象类型
     *              的属性和方法。
     *     构造函数模式用大写字母开头，可以区别于其他函数。
     *     与工厂模式不同，构造函数模式没有显示地创建对象，并且直接将属性和方法赋给了this对象，而且不需要return.
     *     创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型。
     *     以这种方式定义的构造函数是在Global对象中的。
     *     缺点每个方法都要在每个实例上重新创建一遍。
     */
    //可以将方法定义转移到构造函数外部，这样就解决了每次都要重新创建实例的问题。
    function sayName(){
        console.log(this.name);
    }

    function Person(name,age,job){
        this.name =name;
        this.age = age;
        this.job = job;
        this.sayName = sayName;
    }
    var person = new Person("cxr",26,"web");
    // 创建的对象都有一个constructor(构造函数属性),该属性都指向Person
    console.log(person.constructor == Person); //true
    console.log(person instanceof Person); //true
    console.log(person instanceof Object); //true
    person.sayName();
    //创建的对象是Person的实例，同时也是Object的实例，因为所有对象均继承自object.

    //构造函数与其他函数不同的地方在于调用方式的不同。 任何函数，只要通过new操作符来调用，那它就可以作为构造函数。如果不使用new,那它和普通函数也不会有什么区别。

    //当做构造函数使用
    var chen = new Person("cxr",24,"销售");
    chen.sayName();
    //作为普通函数调用
    Person("chen",25,"111");  //在window对象中
    window.sayName();
    //在另一个对象的作用域中
    var o = new Object();
    Person.call(o,"chenxueru",23,"123");
    o.sayName();
    //不同实例上的同名函数是不相等的，
    console.log(chen.sayName == person.sayName);  //false

    /**
     * 原型模式   
     *每个创建的函数都有一个prototype(原型)属性，这个属性是一个指向对象的指针，而这个对象是包含可以由特定类型的所有实例共享的属性和方法。
     *          这个原型也叫原型对象，从而可以不必再构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中。
     */
    function  Human (){

    }
    Human.prototype.name = "chen";
    Human.prototype.age = 25;
    Human.prototype.sayName = function(){
        console.log(this.name)
    };
    var Human1 = new Human();
    var Human2 = new Human();
    console.log(Human1.name);  //chen
    console.log(Human2.name);  //chen
    console.log(Human1.sayName == Human2.sayName); // true
    /*
<<<<<<< HEAD
      无论什么时候，只要创建了一个新的函数，就会根据一组特定的规则为该函数创建一个prototype属性，指向这个函数的原型对象。默认情况下，所有的原型对象都会自动获得一个constructor(构造函数)属性，这个属性是一个指向prototype属性所在的函数（“即创建的那个函数”）。
    */
    console.log(Human); 
    // isPrototypeOf() . 用来确定俩个对象之间是否存在
</script>
=======
    创建一个函数，就会为函数创建一个prototype属性，他是个指针，指向这个函数的原型对象。
    原型对象含有一个constructor（构造函数）属性，指向prototype属性所在的那个函数（即“创建的那个函数”）。。
    */
   console.log(Human);
   console.log(Human.prototype); //指向自定义构造函数的原型对象。
   console.log(Human.prototype.constructor);
   console.log(Human1.constructor);  //Human构造函数 
   //用isPrototypeOf()方法来判断实例对象和原型是否存在关系,返回布尔值.
   console.log(Human.prototype.isPrototypeOf(Human1));  //true
   // Object.getPrototypeOf(),用来返回构造函数的原型对象。
   console.log(Object.getPrototypeOf(Human1) == Human.prototype); //true 
   console.log(Object.getPrototypeOf(Human1));  //返回原型对象。
   //多个实例共享原型属性方法的原理：先搜索实例本身，如果没有就搜索他的原型对象
   //当给对象实例添加一个新的属性的时候，这个实例会屏蔽原型对象中保存的同名实例，但是不会修改那个属性，可以使用delete操作符来删除实例属性。
   Human1.name = "xue";
   console.log(Human1.name);  //"xue"  来自实例
   console.log(Human2.name);  //"chen" 来自原型
   delete Human1.name;
   console.log(Human1.name);  // chen  来自原型
   /**
    * 使用从Objcet中继承的hasOwnProperty()可以分辨出属性来自于实例还是原型。
    */
   console.log(Human1.hasOwnProperty("name")); // false  来自原型
   Human2.name = "ru";
   console.log(Human2.hasOwnProperty("name")); //true  来自实例
   // Object.getOwnPropertyDescriptor 获取属性的描述符，但是只能在原型对象上调用
   console.log(Object.getOwnPropertyDescriptor(Human1,"name"));  //undefined
   console.log(Object.getOwnPropertyDescriptor(Human1.__proto__,"name")); // 返回描述符


   /*
        原型于in操作符
        in操作符俩种使用方式：单独使用与在for in中使用。
    */
   //单独使用:通过对象能够访问给定属性时返回true，不论它来自实例还是原型。
   //而hasOwnProperty() 只有在属性来自于实例的时候返回true；
   console.log("name" in Human1);  //true
   console.log(Human2.hasOwnProperty("name"));  //true  来自实例 

   //！！！判定一个属性在原型还是在实例
    function a(obj,name){
        return (name in obj) && !obj.hasOwnProperty(name);
    }

   // for in 中使用： 返回所有能够通过对象访问的和枚举的属性，无论它存在实例还是存在原型中。屏蔽了原型中不可枚举属性的实例属性也会返回。
   for(var person3 in Human1){
        console.log(person3);  // name age sayName
   }
   //也可以直接使用ECMAScript5提供的Object.key()方法来枚举属性。接收一个对象作为参数。
   var keys = Object.keys(Human.prototype);
   console.log(keys); //["name", "age", "sayName"] 
   //使用Object.getOwnPropertyNames来得到所有的实例属性，不管他是不是可以枚举。
   var keyss = Object.getOwnPropertyNames(Human.prototype)
   console.log(keyss); //["constructor", "name", "age", "sayName"]
</script>   
>>>>>>> 595e098fb295b8747fb13ed594a58f047119edf1
</body>
</html>
